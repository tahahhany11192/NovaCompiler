<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" type="image/jpg" href="logo2.jpg">
  <meta charset="UTF-8">
  <title>Pseudocode Compiler</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #1a2980, #26d0ce);
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }

    .container {
      max-width: 1000px;
      margin: 40px auto;
      background: linear-gradient(120deg, #ffffff 70%, #e0e7ff 100%);
      padding: 30px;
      border-radius: 18px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.28);
      border: 2px solid #5d9bff;
    }

h1 {
  font-family: 'Segoe UI', 'Montserrat', 'Arial', sans-serif;
  font-size: 2.8rem;
  font-weight: 900;
  letter-spacing: 3px;
  background: linear-gradient(90deg, #1a2980 30%, #26d0ce 100%);
  color: transparent;
  -webkit-background-clip: text;
  background-clip: text;
  text-align: center;
  margin-bottom: 10px;
  text-shadow: 2px 4px 12px #b3c6ff44;
  transition: 
    text-shadow 0.4s cubic-bezier(.4,0,.2,1),
    transform 0.4s cubic-bezier(.4,0,.2,1),
    filter 0.4s cubic-bezier(.4,0,.2,1);
}

h1:hover {
  text-shadow: 2px 8px 24px #26d0ce99;
  transform: scale(1.04) rotate(-1deg);
  filter: brightness(1.15);
}

    .subtitle {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 20px;
      font-style: italic;
    }

    textarea {
      width: 95%;
      height: 250px;
      font-family: 'Fira Code', monospace;
      font-size: 16px;
      padding: 15px;
      border: 2px solid #5d9bff;
      border-radius: 10px;
      margin-top: 10px;
      background: #f8fbff;
      transition: all 0.3s;
      line-height: 1.5;
      box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    textarea:focus {
      border: 2px solid #ff6b6b;
      outline: none;
      background: #fff;
      box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.2);
    }

    .btn-group {
      display: flex;
      gap: 15px;
      margin-top: 20px;
    }

    button {
      flex: 1;
      padding: 14px 32px;
      background: linear-gradient(90deg, #1a2980 0%, #26d0ce 100%);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      box-shadow: 0 4px 16px rgba(26, 41, 128, 0.3);
      transition: all 0.3s;
      letter-spacing: 1px;
      outline: none;
      position: relative;
      overflow: hidden;
    }
    
    button:before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: 0.5s;
    }
    
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 24px rgba(26, 41, 128, 0.4);
    }
    
    button:hover:before {
      left: 100%;
    }
    
    button:active {
      transform: translateY(1px);
    }

    #runBtn {
      background: linear-gradient(90deg, #00c853 0%, #1de9b6 100%);
      box-shadow: 0 4px 16px rgba(0, 200, 83, 0.3);
    }

    #clearBtn {
      background: linear-gradient(90deg, #ff5252 0%, #ff867c 100%);
      box-shadow: 0 4px 16px rgba(255, 82, 82, 0.3);
    }

    .code-line {
      padding: 10px 15px;
      border-radius: 8px;
      font-family: 'Fira Code', monospace;
      display: flex;
      align-items: center;
      margin-bottom: 5px;
      background: linear-gradient(90deg, #edf2ff 60%, #e3fafc 100%);
      border-left: 5px solid #5d9bff;
      transition: all 0.3s;
      font-size: 15px;
    }

    .highlight {
      background: linear-gradient(90deg, #1a2980 60%, #26d0ce 100%);
      font-weight: bold;
      color: #fff;
      border-left: 5px solid #ff6b6b;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .arrow {
      color: #1a2980;
      font-weight: bold;
      margin-right: 12px;
      width: 24px;
      display: inline-block;
      font-size: 22px;
      transition: all 0.3s;
    }

    .arrow.active {
      color: #ffeb3b;
      transform: scale(1.2);
    }

    .arrow::after {
      content: '';
    }

    .arrow.active::after {
      content: 'âž¤';
    }

    .code-output, .explanation {
      margin-top: 25px;
      background: linear-gradient(90deg, #1e1e1e 80%, #1a2980 100%);
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      font-family: 'Fira Code', monospace;
      white-space: pre-wrap;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
      border: 2px solid #5d9bff;
      min-height: 100px;
    }

    .explanation {
      background: linear-gradient(90deg, #f8fbff 80%, #e3fafc 100%);
      color: #2c3e50;
      font-family: 'Segoe UI', sans-serif;
      border: 2px solid #1de9b6;
      box-shadow: 0 2px 12px rgba(29, 233, 182, 0.2);
    }
    
    .output-title {
      color: #26d0ce;
      font-weight: bold;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
    }
    
    .output-title svg {
      margin-right: 10px;
    }
    
    .success {
      color: #1de9b6;
    }
    
    .error {
      color: #ff6b6b;
    }

    .header-logo {
  height: 80px;
  vertical-align: middle;
  margin-right: 10px;
  transition: 
    transform 0.4s cubic-bezier(.4,0,.2,1),
    box-shadow 0.4s cubic-bezier(.4,0,.2,1),
    filter 0.4s cubic-bezier(.4,0,.2,1);
  border-radius: 18px;
  box-shadow: 0 2px 12px #1a298033;
}

.header-logo:hover {
  transform: scale(1.07) rotate(-2deg);
  filter: brightness(1.15);
  box-shadow: 0 8px 32px #26d0ce55;
}
  </style>
</head>
  <div style="text-align:center; margin-bottom: 10px;">
    <img src="logo.png" alt="Logo" style="height:200px; vertical-align:middle; margin-right:10px;" class="header-logo">
  </div>
<body>
  <div class="container">
    <h1>Pseudocode Compiler</h1>
<label for="codeInput"><strong>Enter your pseudocode:</strong></label>
    <textarea id="codeInput" placeholder="Example:
Declare x : INTEGER   
 x <- 5
OUTPUT x"></textarea>
<div class="btn-group">
  <button id="autoRunBtn" onclick="runAuto()">Run Automatically</button>
  <button id="stepBtn" onclick="runStep()">Next Step</button>
  <button id="clearBtn" onclick="location.reload()">Clear</button>
</div>

<div id="codeDisplay"></div>
<div class="code-output" id="outputBox"></div>
<div class="explanation" id="explanationBox"></div>

 <script>
        let executionState = {
            lineElements: [],
            variables: {},
            output: '',
            currentLine: 0,
            stack: [],
            isRunning: false,
            autoRunInterval: null,
            rawLines: []
        };

function getBlockEnd(startLine) {
    const startLineText = executionState.rawLines[startLine];
    const startIndent = startLineText.search(/\S/);
    let depth = 0;
    
    for (let i = startLine + 1; i < executionState.rawLines.length; i++) {
        const currentLine = executionState.rawLines[i];
        const currentIndent = currentLine.search(/\S/);
        
        if (currentIndent === -1) continue; // Skip empty lines
        
        // Check for block starters
        if (/^\s*(IF|FOR|WHILE|REPEAT)\b/i.test(currentLine)) {
            depth++;
            continue;
        }
        
        // Check for block terminators
        if (/^\s*(END IF|NEXT|ENDWHILE|UNTIL)\b/i.test(currentLine)) {
            if (depth > 0) {
                depth--;
                continue;
            }
            // Special case: END IF must match IF indentation
            if (/^\s*END IF\b/i.test(currentLine)) {
                const endIfIndent = currentLine.search(/\S/);
                if (endIfIndent !== startIndent) {
                    continue; // Keep searching for properly indented END IF
                }
            }
            return i;
        }
        
        // Base case for same-level termination
        if (currentIndent <= startIndent && depth === 0) {
            return i;
        }
    }
    return executionState.rawLines.length;
}

        function prepareExecution() {
            const codeArea = document.getElementById('codeInput');
            const rawLines = codeArea.value.split('\n');
            const codeDisplay = document.getElementById('codeDisplay');

            codeDisplay.innerHTML = '';
            document.getElementById('outputBox').textContent = '';
            document.getElementById('explanationBox').textContent = 'Starting execution...';

            executionState = {
                lineElements: [],
                variables: {},
                output: '',
                currentLine: 0,
                stack: [],
                isRunning: true,
                autoRunInterval: null,
                rawLines
            };

            executionState.lineElements = rawLines.map((line, index) => {
                const div = document.createElement('div');
                div.className = 'code-line';
                div.dataset.line = index;
                
                const arrow = document.createElement('span');
                arrow.className = 'arrow';
                div.appendChild(arrow);
                
                const text = document.createElement('span');
                text.textContent = line;
                div.appendChild(text);
                
                codeDisplay.appendChild(div);
                return { container: div, arrow, text };
            });
        }

        function escapeString(str) {
            return str.replace(/"/g, '\\"');
        }

        function replaceVars(expr) {
            let logicalExpr = expr
                .replace(/\bAND\b/gi, '&&')
                .replace(/\bOR\b/gi, '||')
                .replace(/\bNOT\b/gi, '!')
                .replace(/\bTRUE\b/gi, 'true')
                .replace(/\bFALSE\b/gi, 'false')
                .replace(/\bMOD\b/gi, '%')
                .replace(/([^<>!])=([^=])/g, '$1===$2')
                .replace(/<>/g, '!==')
                .replace(/<=/g, '<=')
                .replace(/>=/g, '>=');

            return logicalExpr.replace(/\b[a-zA-Z_]\w*\b/g, word => {
                if (executionState.variables.hasOwnProperty(word)) {
                    const value = executionState.variables[word];
                    if (typeof value === 'string') {
                        return `"${escapeString(value)}"`;
                    }
                    return value;
                }
                return word;
            });
        }

        function evalInScope(expr, variables) {
            try {
                const varNames = Object.keys(variables);
                const varValues = varNames.map(name => variables[name]);
                
                if (/^".*"$/.test(expr.trim())) {
                    return expr.trim().slice(1, -1);
                }
                
                if (!isNaN(expr)) {
                    return parseFloat(expr);
                }
                
                return Function(...varNames, `return (${expr})`)(...varValues);
            } catch (err) {
                console.error(`Error evaluating: ${expr}`, err);
                throw new Error(`Evaluation error in expression: ${expr} - ${err.message}`);
            }
        }

        function executeNextStep() {
            if (executionState.currentLine >= executionState.rawLines.length) {
                executionState.isRunning = false;
                document.getElementById('explanationBox').textContent += '\n\nExecution complete.';
                clearInterval(executionState.autoRunInterval || 0);
                document.getElementById('autoRunBtn').textContent = 'Run Automatically';
                return false;
            }

            const rawLine = executionState.rawLines[executionState.currentLine];
            const line = rawLine.trim();
            const { container, arrow } = executionState.lineElements[executionState.currentLine];

            executionState.lineElements.forEach(el => {
                el.container.classList.remove('highlight');
                el.arrow.classList.remove('active');
            });
            
            container.classList.add('highlight');
            arrow.classList.add('active');
            
            try {
                const exBox = document.getElementById('explanationBox');
                if (line === '') {
                    exBox.textContent = 'Skipping empty line.';
                    executionState.currentLine++;
                    return true;
                }

                // DECLARE
                if (/^DECLARE\s+(.+)\s*:\s*(INTEGER|REAL|STRING)$/i.test(line)) {
                    const [, varList, type] = line.match(/^DECLARE\s+(.+)\s*:\s*(INTEGER|REAL|STRING)$/i);
                    const vars = varList.split(',').map(v => v.trim());
                    vars.forEach(v => {
                        executionState.variables[v] = type === 'STRING' ? "" : 0;
                    });
                    exBox.textContent = `Declared ${vars.join(', ')} as ${type}`;
                    executionState.currentLine++;
                    return true;
                }

                // Assignment
                if (/^(\w+)\s*<-\s*(.+)$/i.test(line)) {
                    const [, varName, valueRaw] = line.match(/^(\w+)\s*<-\s*(.+)$/i);
                    const val = valueRaw.trim();
                    
                    if (/^".*"$/.test(val)) {
                        executionState.variables[varName] = val.slice(1, -1);
                    } else {
                        try {
                            executionState.variables[varName] = evalInScope(replaceVars(val), executionState.variables);
                        } catch (e) {
                            if (executionState.variables.hasOwnProperty(val)) {
                                executionState.variables[varName] = executionState.variables[val];
                            } else {
                                throw e;
                            }
                        }
                    }
                    exBox.textContent = `Assigned ${varName} = ${executionState.variables[varName]}`;
                    executionState.currentLine++;
                    return true;
                }

                // INPUT
                if (/^INPUT\s+(.+)$/i.test(line)) {
                    const varList = line.match(/^INPUT\s+(.+)$/i)[1].split(',').map(v => v.trim());
                    for (let v of varList) {
                        let val = prompt(`Enter value for ${v}:`);
                        if (val === null) {
                            exBox.textContent = "Execution canceled by user";
                            stopExecution();
                            return false;
                        }
                        executionState.variables[v] = isNaN(val) ? val : Number(val);
                    }
                    exBox.textContent = `Input received for: ${varList.join(', ')}`;
                    executionState.currentLine++;
                    return true;
                }

                // OUTPUT
                if (/^OUTPUT\s+(.+)$/i.test(line)) {
                    const expressions = line.match(/^OUTPUT\s+(.+)$/i)[1].split(',').map(e => e.trim());
                    const values = expressions.map(e => {
                        if (/^".*"$/.test(e)) {
                            return e.slice(1, -1);
                        }
                        try {
                            return evalInScope(replaceVars(e), executionState.variables);
                        } catch (err) {
                            return e;
                        }
                    });
                    const combined = values.join(' ');
                    executionState.output += combined + '\n';
                    document.getElementById('outputBox').textContent = executionState.output;
                    exBox.textContent = `Outputting: ${combined}`;
                    executionState.currentLine++;
                    return true;
                }
// IF handler
if (/^IF\s+(.+)\s+THEN$/i.test(line)) {
    const condition = line.match(/^IF\s+(.+)\s+THEN$/i)[1];
    const jsCondition = replaceVars(condition);
    const result = evalInScope(jsCondition, executionState.variables);
    
    // Find the matching END IF at the same indentation level
    const currentIndent = executionState.rawLines[executionState.currentLine].search(/\S/);
    let endIfIndex = -1;
    let elseIndex = -1;
    
    for (let j = executionState.currentLine + 1; j < executionState.rawLines.length; j++) {
        const lineText = executionState.rawLines[j];
        const lineIndent = lineText.search(/\S/);
        
        if (lineIndent === -1) continue;
        
        if (/^\s*END IF\s*$/i.test(lineText) && lineIndent === currentIndent) {
            endIfIndex = j;
            break;
        }
        
        if (/^\s*ELSE\s*$/i.test(lineText) && lineIndent === currentIndent) {
            elseIndex = j;
        }
    }
    
    if (endIfIndex === -1) {
        exBox.textContent = "Error: Missing END IF";
        executionState.isRunning = false;
        return false;
    }

    executionState.stack.push({ 
        type: 'IF', 
        startLine: executionState.currentLine,
        endLine: endIfIndex,
        elseLine: elseIndex !== -1 ? elseIndex : null,
        executed: result
    });

    if (result) {
        exBox.textContent = "IF condition TRUE, executing block.";
        executionState.currentLine++;
    } else {
        executionState.currentLine = elseIndex !== -1 ? elseIndex + 1 : endIfIndex + 1;
        exBox.textContent = "IF condition FALSE, skipping block.";
    }
    return true;
}

// ELSE handler
if (/^ELSE$/i.test(line)) {
    const ifBlock = executionState.stack[executionState.stack.length - 1];
    if (!ifBlock || ifBlock.type !== 'IF') {
        exBox.textContent = "Error: ELSE without matching IF";
        executionState.isRunning = false;
        return false;
    }
    
    // Jump to END IF
    executionState.currentLine = ifBlock.endLine + 1;
    return true;
}

// END IF handler
if (/^END IF$/i.test(line)) {
    const ifBlock = executionState.stack.pop();
    if (!ifBlock || ifBlock.type !== 'IF') {
        exBox.textContent = "Error: END IF without matching IF";
        executionState.isRunning = false;
        return false;
    }
    executionState.currentLine++;
    return true;
}

                // FOR loop - FIXED
if (/^FOR\s+(\w+)\s*<-\s*(\w+|\d+)\s+TO\s+(\w+|\d+)(?:\s+DO)?$/i.test(line)) {
    const [, varName, startStr, endStr] = line.match(/^FOR\s+(\w+)\s*<-\s*(\w+|\d+)\s+TO\s+(\w+|\d+)(?:\s+DO)?$/i);

    const start = isNaN(startStr) ? 
        (executionState.variables.hasOwnProperty(startStr) ? executionState.variables[startStr] : parseInt(startStr)) : 
        parseInt(startStr);

    const end = isNaN(endStr) ? 
        (executionState.variables.hasOwnProperty(endStr) ? executionState.variables[endStr] : parseInt(endStr)) : 
        parseInt(endStr);

    executionState.variables[varName] = start;

    executionState.stack.push({
        type: 'FOR',
        line: executionState.currentLine,
        varName: varName,
        end: end
    });

    exBox.textContent = `FOR loop started: ${varName} from ${start} to ${end}`;
    executionState.currentLine++;
    return true;
}



if (/^NEXT$/i.test(line)) {
    // Find the last FOR in the stack (top-most unmatched FOR)
    for (let i = executionState.stack.length - 1; i >= 0; i--) {
        const loop = executionState.stack[i];
        if (loop.type === 'FOR') {
            const varName = loop.varName;
            executionState.variables[varName]++;

            if (executionState.variables[varName] <= loop.end) {
                executionState.currentLine = loop.line + 1;
                exBox.textContent = `Looping again FOR ${varName} = ${executionState.variables[varName]}`;
            } else {
                executionState.stack.splice(i, 1);  // Remove this FOR loop
                executionState.currentLine++;
                exBox.textContent = `Exiting FOR loop (${varName})`;
            }
            return true;
        }
    }

    exBox.textContent = "Error: NEXT without matching FOR";
    executionState.isRunning = false;
    return false;
}




                // WHILE
                if (/^WHILE\s+(.+)\s+DO$/i.test(line)) {
                    const condition = line.match(/^WHILE\s+(.+)\s+DO$/i)[1];
                    const result = evalInScope(replaceVars(condition), executionState.variables);
                    
                    if (!result) {
                        let depth = 0;
                        for (let j = executionState.currentLine + 1; j < executionState.rawLines.length; j++) {
                            const checkLine = executionState.rawLines[j].trim();
                            if (/^WHILE\s+.+\s+DO$/i.test(checkLine)) depth++;
                            else if (/^ENDWHILE$/i.test(checkLine)) {
                                if (depth === 0) {
                                    executionState.currentLine = j + 1;
                                    exBox.textContent = `Skipping WHILE loop.`;
                                    return true;
                                } else {
                                    depth--;
                                }
                            }
                        }
                    }
                    
                    executionState.stack.push({ 
                        type: 'WHILE', 
                        line: executionState.currentLine, 
                        condition 
                    });
                    
                    exBox.textContent = `Entering WHILE loop.`;
                    executionState.currentLine++;
                    return true;
                }

                // ENDWHILE
                if (/^ENDWHILE$/i.test(line)) {
                    const loopIndex = executionState.stack.findIndex(item => item.type === 'WHILE');
                    if (loopIndex === -1) {
                        exBox.textContent = "Error: ENDWHILE without matching WHILE";
                        executionState.isRunning = false;
                        return false;
                    }
                    
                    const loop = executionState.stack[loopIndex];
                    const result = evalInScope(replaceVars(loop.condition), executionState.variables);
                    
                    if (result) {
                        executionState.currentLine = loop.line + 1;
                        exBox.textContent = "Repeating WHILE loop.";
                    } else {
                        executionState.stack.splice(loopIndex, 1);
                        executionState.currentLine++;
                        exBox.textContent = "Exiting WHILE loop.";
                    }
                    return true;
                }

                // REPEAT
                if (/^REPEAT$/i.test(line)) {
                    executionState.stack.push({ 
                        type: 'REPEAT', 
                        line: executionState.currentLine 
                    });
                    exBox.textContent = "Entering REPEAT loop.";
                    executionState.currentLine++;
                    return true;
                }

                // UNTIL
                if (/^UNTIL\s+(.+)$/i.test(line)) {
                    const condition = line.match(/^UNTIL\s+(.+)$/i)[1];
                    const result = evalInScope(replaceVars(condition), executionState.variables);
                    
                    const loopIndex = executionState.stack.findIndex(item => item.type === 'REPEAT');
                    if (loopIndex === -1) {
                        exBox.textContent = "Error: UNTIL without matching REPEAT";
                        executionState.isRunning = false;
                        return false;
                    }
                    
                    if (result) {
                        executionState.stack.splice(loopIndex, 1);
                        executionState.currentLine++;
                        exBox.textContent = "Exiting REPEAT loop.";
                    } else {
                        const loop = executionState.stack[loopIndex];
                        executionState.currentLine = loop.line + 1;
                        exBox.textContent = "Repeating REPEAT loop.";
                    }
                    return true;
                }

                exBox.textContent = `Unknown command: ${line}`;
                executionState.currentLine++;
                return true;

            } catch (err) {
                document.getElementById('explanationBox').textContent = `Error: ${err.message || err}`;
                executionState.isRunning = false;
                clearInterval(executionState.autoRunInterval || 0);
                document.getElementById('autoRunBtn').textContent = 'Run Automatically';
                return false;
            }
        }

        function runAuto() {
            if (executionState.isRunning) {
                clearInterval(executionState.autoRunInterval || 0);
                executionState.autoRunInterval = null;
                executionState.isRunning = false;
                document.getElementById('autoRunBtn').textContent = 'Run Automatically';
                return;
            }

            prepareExecution();
            document.getElementById('autoRunBtn').textContent = 'Stop Execution';

            executionState.autoRunInterval = setInterval(() => {
                const continueExecution = executeNextStep();
                if (!continueExecution) {
                    clearInterval(executionState.autoRunInterval);
                    executionState.autoRunInterval = null;
                    document.getElementById('autoRunBtn').textContent = 'Run Automatically';
                }
            }, 1500);
        }

        function runStep() {
            if (!executionState.isRunning) {
                prepareExecution();
            }
            if (executionState.currentLine < executionState.rawLines.length) {
                executeNextStep();
            } else {
                document.getElementById('explanationBox').textContent += '\n\nExecution complete.';
                executionState.isRunning = false;
            }
        }
        
        function stopExecution() {
            if (executionState.autoRunInterval) {
                clearInterval(executionState.autoRunInterval);
                executionState.autoRunInterval = null;
            }
            executionState.isRunning = false;
            document.getElementById('autoRunBtn').textContent = 'Run Automatically';
            document.getElementById('explanationBox').textContent += '\n\nExecution stopped by user.';
        }
        
        function resetCompiler() {
            stopExecution();
            document.getElementById('codeInput').value = '';
            document.getElementById('codeDisplay').innerHTML = '';
            document.getElementById('outputBox').textContent = '';
            document.getElementById('explanationBox').textContent = 'Enter your pseudocode and click "Run Next Step" or "Run Automatically"';
            executionState = {
                lineElements: [],
                variables: {},
                output: '',
                currentLine: 0,
                stack: [],
                isRunning: false,
                autoRunInterval: null,
                rawLines: []
            };
        }
    </script>

  <div style="text-align:center; margin-top:40px; color:#000000; font-size:60px;">
    &copy; 2025 Nova-tech. All rights reserved.
  </div>
</body>
</html>
